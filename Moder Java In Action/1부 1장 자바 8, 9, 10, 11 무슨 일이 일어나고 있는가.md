# 1.1 역사의 흐름은 무엇인가?

> 데이터베이스 질의 언어에서 고수준 언어로 원하는 동작을 표현하면 구현에서 최적의 저수준 실행 방법을 선택하는 방식으로 동작한다.

- 구현하는 과정은 자바의 Stream 라이브러리에서 진행한다.

> 즉, 스트림을 이용하면 에러를 자주 일으키며 멀티코어 CPU 를 이용하는 것보다 비용이 훨씬 비싼 키워드인 `synchronized`를 사용하지 않아도 된다.

—> 멀티코어 CPU 의 각 코어는 별도의 캐시를 포함하고 있다. 락을 사용하면 이러한 캐시가 동기화되어야 하므로 속도가 느린 캐시 일관성 프로토콜 인터코어 통신이 이루어진다.


## 1.2.2 스트림 처리

> **스트림림** 이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다. 
<br>이론적으로 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다. 즉, 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.


> 스트림 패키지 (`java.util.stream`) 에 정의된 Stream<T> 은 T 형식으로 구성된 일련의 항목을 의미한다. 
핵심은 기존에는 한 번에 한 항목을 처리했지만 이제 자바 8에서는 우리가 하려는 작업을 고수준으로 추상화화해서 일련의 스트림으로 만들어 처리할 수 있다는 것이다. 
<br>또한 스트림 파이프라인을 이용해 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다는 부가적인 이득도 얻을 수 있다.
스레드라는 복잡한 작업을 사용하지 않으면서도 공짜로 병렬성을 얻을 수 있다.
> 

## 1.2.3 동작 파라미터화로 메서드에 코드 전달하기

> 동작 파라미터화가 중요한 이유는 스트림 API 연산의 동작을 파라미터화 할 수 있는 코드를 전달하는 것에 기초하기 때문이다.
> 

## 1.2.4 병렬성과 공유 가변 데이터

> 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행 될 수 있어야 한다. 보통 이러한 코드를 만드려면 공유된 가변 데이터에 접근하지 않아야 한다. 이러한 함수를 `순수 함수`, 부작용이 없는 함수, 상태 없는 함수라 부른다.

<details>
<summary> 순수 함수에 대해서 </summary>
<div markdown="1">

입력값이 같으면 항상 같은 출력값을 반환하고, 외부 상태를 변경하지 않는 함수를 의미함함. 즉, 부작용이 없고, 공유된 가변 데이터에 접근하지 않는 것이 특징

</div>
</details>
<br>

> 기존처럼 `synchronized` 를 이용해서 공유된 가변 데이터를 보호하는 규칙을 만들 수는 있다. 하지만 자바 8의 스트림을 이용하면 기존의 자바 스레드 api 보다 쉽게 병렬성을 활용할 수 잇다
<br>다중 프로세싱 코어에서 `synchronized` 를 사용하는 것은 훨씬 힘든 일이 될 수 있다 (다중 처리 코어에서는 코드가 순차적으로 실행되어야 하므로 병렬이라는 목적을 무력화시키면서 사용하게 된다)
> 

> 공유되지 않은 가변 데이터, 메서드, 함수 코드를 다른 메서드로 전달하는 두 가지 기능은 함수형 프로그래밍 패러다임의 핵심적인 사항이다.
<br>반면에 명령형 프로그래밍 패러다임에서는 일련의 가변 상태로 프로그램을 정의한다.
<br>공유되지 않은 가변 데이터 요구사항이란 인수를 결과로 변환하는 기능과 관련된다. 즉, 이 요구사항은 수학적인 함수처럼 함수가 정해진 기능만 수행하며 다른 부작용은 일으키지 않음을 의미한다.
> 

## 1.3.1 메서드와 람다를 일급 시민으로

### 메서드 참조

> 예를 들어, 디렉터리에서 모든 숨겨진 파일을 필터링한다고 했을 때 우선 주어진 파일이 숨겨져 있는지 여부를 알려주는 메서드를 구현해야 한다.
<br>File 클래스의 `isHidden` 은 File 클래스를 인수로 받아 boolean 을 반환하는 함수이다. 
<br>다음 코드처럼 FileFilter 객체 내부에 위치한 `isHidden` 의 결과를 File.listFiles 메서드로 전달하는 방법으로 숨겨진 파일을 필터링할 수 있다.
> 

```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter(){
	public boolean accept(File file){
		return file.isHidden(); // 숨겨진 파일 필터링
	}
});
```

> 그런데 File 클래스에는 이미 isHidden 이라는 메서드가 있는데 왜 굳이 FileFilter 로 isHidden 을 복잡하게 감싼 다음에 FileFilter 를 인스턴스화 해야 하는 걸까?
<br> → 자바 8이 나오기 전까지는 달리 방법이 없었다. 이제 자바 8에서는 코드를 다음처럼 구현할 수 있다.
> 

```java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

> 자바 8의 메서드 참조 `::` (이 메서드를 값으로 사용하라는 의미) 를 이용해서 listFiles 에 직접 전달할 수 있다. 
<br>기존에 new 를 사용한 객체 참조를 이용해서 객체를 이리저리 주고 받았던 것처럼 자바 8에서는 메서드 참조를 만들어 전달 할 수 있게 되었다.
> 



## 1.3.3 메서드 전달에서 람다로

> 자바 8에서는 익명 함수로 또는 람다를 이용하여 한 번만 사용할 메서드는 따로 정의를 구현하지 않고도 기능을 구현할 수 있있다.
<br>하지만 람다가 몇 줄 이상으로 길어진다면 익명 람다 보다는 코드가 수행하는 일을 잘 설명하는 이름을 가진 메서드를 정의하고 메서드 참조를 활용하는 것이 바람직하다. 코드의 명확성이 우선시되어야 한다.
> 

# 1.4 스트림

> 스트림 API 를 이용하면 컬렉션 API 와는 상당히 다른 방식으로 데이터를 처리할 수 있다. 컬렉션에서는 반복 과정을 직접 처리해야 했다. <br>즉, **for-each 루프**를 이용해 각 요소를 반복하면서 작업을 수행했다. 이런 방식의 반복을 **외부 반복**이라고 한다. <br>반면 스트림 API 를 이용하면 루프를 신경 쓸 필요가 없다. 스트림 API 에서는 라이브러리 내부에서 모든 데이터가 처리된다. 이와 같은 반복을 **내부 반복**이라고 한다.
> 

## 1.4.1 멀티스레딩은 어렵다

> 멀티스레딩 환경에서 각각의 스레드는 동시에 공유된 데이터에 접근하고 데이터를 갱신할 수 있다. 결과적으로 스레드를 잘 제어하지 못하면 원치 않는 방식으로 데이터가 바뀔 수 있다.
<br>전통적으로 멀티스레딩 환경에서는 `synchronized` 를 자주 활용하지만 이를 활용하더라도 많은 미묘한 버그가 발생할 수 있다. <br>자바 8에서는 `synchronized` 가 필요하지 않은 함수형 프로그래밍 형식의 스트림 기반 병렬성을 이용하도록 권고한다. 자바 8에서는 데이터터 접근 방법을 제어하는 것이 아니라 어떻떻게 데이터를 분할할지 고민하게 된다.


> 자바 8은 스트림 API 로 컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제, 그리고 멀티코어 활용의 어려움이라는 두 문제를 모두 해결했다. 
<br>자주 반복되는 패턴으로 주어진 조건에 따라 데이터를 필터링하거나 데이터를 추출하거나 데이터를 그룹화하는 등의 기능이 있다.

> 두 CPU 를 가진 환경에서 리스트를 필터링 할 때 한 CPU 는 리스트의 앞부분을 처리하고 다른 CPU 는 리스트의 뒷부분을 처리하도록 요청할 수 있다. 이 과정을 **포킹 단계**라고 한다. <br>이 단계를 지나 각각의 CPU 는 자신이 맡은 절반의 리스트를 처리하고 나면 마지막으로 하나의 CPU 가 두 결과를 정의한다.

> 스트림은 스트림 내의 요소를 쉽게 병렬로 처리할 수 잇는 환경을 제공한다는 것이 핵심이다. 컬렉션을 필터링할 수 있는 가장 빠른 방법은 컬렉션을 스트림으로 바꾸고 병렬로 처리한 다음에에 리스트로 다시 복원하는 것이다.


```java
// 순차 처리 방식
List<Apple> heavyApples = 
	inventory.stream().filter((Apple a) -> a.getWeight() > 150)
										.collect(toList());
										
// 병렬 처리 방식
List<Apple> heavyApples =
	inventory.parallelStream().filter((Apple a) -> a.getWeight() > 150)
														.collect(toList());
```


💡순차 처리 방식의 코드와 병렬처리 방식의 코드를 보면 순차 처리 방식에서는 `stream()` 을 사용했고, 병렬 처리 방식에서는 `parallelStream` 의 차이만 있는 것을 확인할 수 있다.
<details>
<summary> 설명 </summary>
<div markdown="1">

`stream()` 와 `parallelStream()` 은 스트림의 처리 방식에 차이가 있다.

<br/>

1. `stream()` 순차 처리 방식
- 단일 스레드에서 요소를 순차적으로 처리한다. 입력된 데이터 순서를 우지하며 한 요소를 처리한 후 다음 요소로 넘어간다.

```
List<Apple> heavyApples = inventory.stream()
									.filter(apple -> apple.getWeight() > 150)
									.collect(Collectors.toList());
```
- 위의 코드에서 stream 은 하나의 스레드에서 `filter()` 연산을 순서대로 수행한다. 안전하지만 데이터가 많으면 성능이 느려질 수 있다.

<br/>

2. `parallelStream()` 병렬 처리 방식
- 여러 개의 스레드를 사용하여 스트림을 병렬로 처리한다. 내부적으로 ForkJoinPool 을 이용하여 작업을 여러 스레드에 분산하여 실행한다.
- 데이터의 순서를 보장하지 않을 수 있다.

```
List<Apple> heavyApples = inventory.parallelStream()
									.filter(apple -> getWeight() > 150)
									.collect(Collectors.toList());
```
- 여러 개의 CPU 코어를 활용하여 filter 작업을 병렬로 수행하여 데이터가 많을 경우 성능이 향상될 수 있다.
- 하지만 작은 데이터에서는 오버헤드가 발생하여 더 느려질 수 있다.
- 병렬 처리 작업이기 때문에 순서가 중요한 작업에서는 한 번 더 고려해보아야 한다.


</div>
</details>
<br>

> 자바의 병렬성과 공유되지 않은 가변 상태
- 자바 8은 큰 스트림을 병렬로 처리할 수 있도록 작은 스트림으로 분할한다. 또한 filter 같은 라이브러리 메서드로 전달된 메서드가 상호작용을 하지 않는다면 가변 공유 객체를 통해 공짜로 병렬성을 누릴 수 있다.
- 함수형 프로그래밍에서 함수형이란 프로그램이 실행되는 동안 컴포넌트 간에 상호 작용이 일어나지 않는다는 의미도 포함한다.
> 

# 1.5 디폴트 메서드와 자바 모듈

> 자바 9의 모듈 시스템은 모듈을 정의하는 문법을 제공하므로 이를 이용해 패키지 모음을 포함하는 모듈을 정의할 수 있다. 모듈 덕분에 JAR 같은 컴포넌트에 구조를 적용할 수 있으며 문서화와 모듈 확인 작업이 용이해졌다.
>